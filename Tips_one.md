# 三十： TCP和UDP区别
### 1. 区别 
	   a. 建立连接方面： TCP在数据传输之前，客户端和服务器会建立通信连接后再数据传输，
	                    而UDP不会建立连接，直接传输数据；
	   b. 占用系统资源方面： TCP由于在建立连接和数据传输时，会进行通信，占用资源较多
	                       UDP不会进行通信，占用资源较少；
	   c. 数据的可靠性： TCP在数据传输时会有确认、窗口、重传、拥塞控制机制，数据的可靠性高，
	                    UDP没有建立连接，是一个无状态的传输协议，数据可靠性差，不保证数据的有序性、完整性等；
	   d. 传输数据的效率、时长： TCP传输要建立连接，传输时还要保证数据的可靠性，程序结构复杂花费时间长，
	                     UDP不建立连接，传输时间短；
	   e. 传输数据的 ： TCP只能是点到点，一个连接是一个服务器对一个客户端传输，而UDP可以实现一对一，
	                  一对多或者多对一，多对多的交互通信
### 2. 优缺点 ：
    a. TCP -- 优点：数据可靠、如果数据丢失，会重发，保证到达的数据的可靠性；
           -- 缺点：传输效率低，花费时间长，占用系统资源高，易被攻击；
    b. UDP -- 优点：数据传输快，安全性比TCP稍微高点，因为传输过程没有那么复杂，也就没有那么多漏洞
                    提供给黑客，但是也是无法完全避免被攻击的；
              缺点：数据的可靠性很差，只是负责传输，不保证数据的完整等性能，可能出现数据丢失、乱序等
### 3. 应用场景：
    TCP -- 对网络通讯的质量要求高，即数据的要求比较高，比如数据要完整的传输给对方，比如HTTP、HTTPS、FTP
           等文件传输协议，POP、SMTP等邮件传输协议，如浏览器用的HTTP FlashFXP，FTP Outlook，POP、
           SMTP Putty，Telnet、SSH QQ文件传输 ；
    UDP -- 对网络通讯质量要求不高，但是对通讯速度要求快，如QQ语音、视频TFTP等等。
# 二十九： MVC / MVT / MVP / MVVM
### 1. MVC -- Model Views Controller -- 模型层、模板层、视图函数
### 2. MVT -- Model Views Templates -- 模型层、视图函数、模板层 
### 3. MVP -- Model Views Presenter -- 模型层、模板层、视图函数（contrller/Presenter）
### 4. MVVM -- Model Views ViewsModel -- 模型层、模板层、视图函数
      将views和状态和抽象化，视图UI和业务逻辑分开，viewsmodel可以取出 Model 的数据同时帮忙处
      理 View 中由于需要展示内容而涉及的业务逻辑。
# 二十八：\_\_str\__和\_\_repr\_\_函数
**两个函数都是object基类中定义用于表达输出结果的魔法函数，开发者可自行重构，但是重构后返回类型必须要是str类型**

应用举例：比方说，现在我想要创建一个类，用来表示人，实例化出一个人的对象，我想用人的名字来代表这个人。直接打印这个对象就输出他的名字，而不是打印他的名字属性才输出名字，如何实现？
         我们首先是创建人这个类，class Person,然后是给他初始化对象属性，可以有性别性别年龄等等，再实例化，a = Person('Susan'),如果就这样，那么print(a)的结果就是:
<__main__.Person object at 0x0000000002422240>，输出结果是内存地址，所以在这
         个时候，我们就要重构str或者是repr方法，也就是说： 当你想要直接打印一个实例化对象，输 出你想要的目标格式，就可以通过重构这两种方法，去实现你自己想要的格式，而不是输出python中object基类默认的内存地址输出格式。

### 1. \__str\__函数
**str将对象的显示格式转换成便于programmer读取的字符串形式**
	
	如果想要输出的显示结果非常友好，有利于用户查看，而不是输出对象的内存地址，可以重构str函数，
	比如print函数，如果给print函数传入一个对象，执行过程是，print函数会默认调用该对象的类的
	str方法，如果该类没有str方法，程序会查找repr方法，没有的话就在父类找，直到object基类，
	如果找到了object，首先打出来str的返回值，也就是该对象在内存中的地址

### 2. \__repr\__函数
**repr将对象的显示格式转换为便于interpreter读取的字符串形式,可以通过eval()对对象进行表达**

	如果想要输出程序能够读取和解析的字符串，可以重构这个repr方法，也就是说这个字符串可以通过eval
	函数来当代码执行的输出格式

### 3. 调用情况：
	重构str函数： 当程序直接输出显示对象时，依然输出内存地址，通过print打印显示对象时，输出str重构的格式
	重构repr函数： 程序直接输出显示和通过print打印输出的结果，都是repr重构的格式，还有就是当再程序开发
	             过程中，需要通过这个输出进行代码交互的时候，需要用repr函数
注意：一般情况下，只考虑输出结果给用户，重构两个中的任何一个都是可以的，
          当我们想所有环境下都统一显示的话，可以重构\__repr\__方法,
          当对象比较复杂，有嵌套层次存在，要重构\__repr\__才有效，因为计算机
          在\__repr\__中能识别出嵌套层的对象，从而将嵌套层的对象也格式化输出，而
          \__str\__函数并不能做到这一点。

![没有重构str或者repr函数时，对象的显示结果.png](https://upload-images.jianshu.io/upload_images/14977853-38e6e0ac4599b70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![重构str后对象的显示结果.png](https://upload-images.jianshu.io/upload_images/14977853-1672ab5bd14fc8a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![重构repr后对象显示结果.png](https://upload-images.jianshu.io/upload_images/14977853-93c286ad5ec83e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 二十七： 数据库的存储过程
**一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果需要）来执行它，返回数据**

	存储过程优点：
	（1） 减少网路通信量：SQL语句不多情况下网络通信量可能没什么区别，当SQL语句成百上千，那么
	                    性能肯定比一条一条的调用SQL语句高得多；
	（2） 执行速度更快: 存储过程在创建的时候数据库会对其进行解析优化，并且存储过程一旦执行，
	                  内存中就会有备份，下次再执行相同存储过程，可以从内存中直接读取；
	（3） 更强的安全性： 存储过程是通过向用户授权而不是基于表，提供特定数据的访问权限，提高代
	                   码安全性，比如房子SQL注入
	（4） 业务逻辑可以封装在存储过程中，容易维护，执行效率高；
	
	缺点：
	（1） 可移植性：从一种数据库迁移到另外一种数据库时，不少的存储过程的编写要进行部分修改；
	（2） 储存过程需要花费一定时间去学习，有自己的语法；

# 二十六：数据库删除操作（谨慎使用）：
        -- 删除数据库： drop database if exists 数据库名；
        -- 删除表：drop table 表名字 （完全删除去掉整张表）；
        -- 删除表：delete from 表名 （删除表里面的数据，一行一行的删除，表明后面可以跟where 字段名= 值，
                  删除指定的某条或者多条记录,该命令可以回滚）
        -- 删除表：truncate table 表名称 （删除表中的数据，并且新增加记录的计数标识会重置，
                  比如主键id原来是50，用该命令删除后，新增加的数据主键id会从1开始，而不是51开始）

       一般来说：执行速度-->drop>truncate>delete
       使用foreign key约束的表，不能用truncate，应使用不带where的delete

# 二十五 : GET和POST的区别：
**本质上来说，GET和POST请求都是TCP链接，TCP/IP都是HTTP的底层协议，它们两做的事情都是一样的，没有区别的，**
**但是由于HTTP协议或者浏览器、服务器对GET和POST的规定，让POST和GET不一样，这种不一样主要体现在以下三点：**

### 1. 请求参数传输方式不同： 
         GET请求的参数放在url中，安全性较低，参数完全暴露在外面，而POST请求的参数放在请求体中，
         安全性相比GET要好
### 2. 允许传递的参数大小不一样：
         GET将参数放在url中，数据量太大，对浏览器和服务器都是很大的负担，所以业界不成文的规
         定大部分浏览器都是限制在2k内，大部分服务器最多处理64k的url，而POST是放在请求体内，
         理论上来说参数大小是不受限的
### 3. GET产生一个TCP数据包，POST产生两个数据包：
         GET请求，浏览器会把HTTP的headers和data一并发出去，服务器返回数据，并响应200状态码；
         但是POST请求是，先发送headers,服务器响应100确认码，继续传输，浏览器再发送data，
         服务器响应数据和200状态码
    ps: 由于POST是两次传输数据，表面上看时间上会多于GET，但是据有关研究表明，在网络状态良好
        的状态下，这个时间差可以完全忽略掉，非常小，但是在网络差的环境下，POST方式可以更好
         的保证数据的完整性。
# 二十四： redis是什么，有什么用？
### 1. redis是什么 -- 
#### a. redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存也可以持久化的日志型、key-value数据库，redis是单线程工作模型，提供多语言的API。

	redis的五种数据类型：
	   1）String: set/get操作，value可以是string或者数字，一般做一些复杂的计数功能的缓存
	   2）hash: value存放的是结构化对象，用这种数据结构存储用户信息，比如以cookieId作为key,
               设置30分钟为缓存过期时间，能很好的模拟出类似session的效果；
	   3)list：可以做简单的消息队列，也可以利用lrange命令，做基于redis的分页功能，性能极佳；
	   4)set ：可以做全局去重功能，利用交集、并集等操作可以计算共同喜好，全部喜好，自己独有的喜好等等功能；
	   5)sorted set ： 比set多了一个权重参数score,集合中的元素能按照score排序，可以做排行榜应用，
                       取top N操作，也可以用来做延时任务，可以做范围查找。
#### b. redis的内存淘汰机制和过期策略
	过期策略 -- 定期删除+惰性删除策略
	定时删除：用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗cpu资
	源。在大并发请求下，cpu要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。
	定期删除：redis默认是100ms检查是否有过期的key，有就删除。需要说明的是，并不是每隔100ms对
	每个key进行检查，而是随机抽取进行检查。
	惰性删除策略：在用户获取某个key的时候，redis会检查一下，这个key如果设置了过期时间，过期了
	就会在此时删除。
	所以，在定期删除+惰性删除结合下，仍然有没有检查到的key,那么就会采用内存淘汰机制。
	内存淘汰机制 -- redis.conf中有一行代码配置内存淘汰机制如下：
            # maxmemory-policy volatile-lru
	配置选项有以下情况：

	1） noeviciton :当内存不足以容纳新写入数据时，新写入操作会报错（报错不符合需求，不推荐）；
	2）allkeys-lru ： 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key；
	3）allkeys-random： 当内存不足以容纳新写入数据时，在键空间中，随机移除某个key；
	4）volatile-lru ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近
	最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用；
	5)volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key；
	6)vloatile-ttl： 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时
	间的key优先移除；
	ps:如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, 
       volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致


### 2. redis和其他持久化数据库混合使用时数据一致性问题 --
 
	首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供
	一个补偿措施即可，例如利用消息队列。这种方式也只能让最终的数据一致，但是如果对数据有强一致
	性要求，这类数据不能完全避免数据的一致性问题，这类数据就不能放缓存。
###3. 如何解决redis的并发竞争key问题 --

# 二十三： 索引与查询效率
**创建索引，可将查询由全表扫描改为索引扫描,其中关系型数据库的关系模型是通过二维表来保存的，它的存储方式是行列组成的表，每一列是一个字段，每一行是一条记录**
### 1.什么是索引：

mysql官方对于索引的定义为：索引是帮助mysql高效获取数据的数据结构，即可以理解为索引是数据结构。实质上，在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式应用数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，通常就是索引表结构。

索引提供指向存储在表的指定列中的数据值得指针，然后根据指定的排序顺序（通常是B树结构）对这些指针排序，数据库使用索引的方式和使用书籍中的索引的方式很相似：它搜索索引找到特征值所在的磁盘块，然后找到包含该值得行。
### 2.索引查询：
	不管数据表有无索引，首先在SGA的数据缓冲区中查找所需要的数据，如果数据缓冲区中没有需要的数据
    时，服务器进程才会去读磁盘。当条件字段没有创建索引时，服务器时直接去读取表数据存放的磁盘块，
    读到数据缓冲区中再查找需要的数据；当该字段有索引，则是先读取索引表，通过索引定位所需数据的物
    理地址，并把数据读入数据缓存区。
### 3.索引的副作用:
     1)索引是有大量数据的时候才建立，没有大量数据反而会浪费时间和资源，因为索引是使用二叉树建立
     2)当一个系统查询比较频繁，而新建和修改等操作比较少时，可以创建索引，这样查询的速度会快很多，
        但是新建或者修改等操作，比没有缩影或者没有建立覆盖索引时要慢
     3)索引并不是越多越好，太多索引会占用很多的索引空间，甚至比存储一条记录更多
对于需要频繁新增记录的表，最好不要创建索引，没有索引的表，执行insert、append都很快，有了索引以后，会多一个维护索引的操作，一些大表可能导致insert速度很慢。

# 二十二 ：django+nginx+uWSGI工作原理
   web服务器架构简述：
      用户请求-> 域名解析层（DNS）-> web服务层（Nginx，Apacha等）-> 应用服务层（uWGSI-django等）-> 数据库层（mysql-orcal等）-> 存储层（光纤存储磁盘等，很少有，贵）

   架构流程：
	客户端请求服务器资源，发送请求，DNS域名解析层解析域名，给Nginx分配ip（默认轮询分配）
	nginx作为直接对外的服务接口，接收到客户端发送过来的请求，会解包，分析
	如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源
	如果是动态的请求，nginx就通过配置文件，将请求传递给uWSGI；uWSGI将接受到的包进行处理，并转发给wsgi，
	wsgi根据请求调用django工程的某个文件或者函数，处理完成后django将返回值交给wsgi
	wsgi将返回值进行打包，转发给uWSGI,
	uWSGI就收后转给nginx，nginx最终将返回值返回给客户端（如浏览器）；
### 1.Nginx -- web服务器
    1）Nginx是Apache的同行，Apache是世界第一大服务器，它的优点是稳定，开源，跨平台等，出现发展的时间很长，所以
         它被设计成一个重量级、不支持高并发的服务器。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存。
         操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低，导致Apache不可
         能成为高性能web服务器。
    2）Nginx是一个俄罗斯工程师用c语言开发的，高性能轻量级的web服务器，也是反向代理服务器，与客户端（如浏览器）直接
         交互，收到客户端的请求（可能是大量），处理http协议和静态页面内容，
         请求按照一定的规则进行分发到不同的服务器进行处理，也就是刚才说的反
          向代理，起到负载均衡的作用。
      Nginx特点如下：
		      a.基于时间驱动框架，使得其可以支持数以百万级别的TCP连接；
		      b.高度的模块化和只有软件许可证使第三方模块层出不穷；
		      c.Nginx是一个跨平台的服务器，可以运行在linux,windows,freebsd,solaris,aix,mac os等操作系统；
		      d.极大的稳定性；
### 2.正、反向代理/负载均衡/'
    a. 正向代理：客户端非常明确要访问的服务器地址，但是并不能直接去访问，需要通过代理服务器，间接访问目标服务器，
                正向代理模式屏蔽或者萤火虫那个人真实客户端信息，所以目标服务器只知道请求来自哪个代理服务器但是并
                不知道具体的那个客户端；

    b. 反向代理：客户端并不知道反向代理的存在，反向代理服务器代理的是服务器端，主要是用于服务器集群分布式部署情况，
               反向代理隐藏了服务器的信息，它的作用是保证内网的安全，将反向代理作为公网访问地址，而真实的web服务
               器是内网，再一个作用就是负载均衡，通过反向代理服务器来优化网站的负载；
    
    c.负载均衡：
    将服务器接收到的请求按照一定的均衡规则分发给其他后端服务器处理的过程，称为负载均衡；
    在实际项目操作过程中，分为硬件和软件两种负载均衡；
    硬负载均衡：也称硬负载，如F5、A10负载均衡，是一个单独的硬件负载均衡服务器，相对造价昂贵成本较高，但是数据的稳
               定性安全性等有很好的保障，如中国移动联通这样的公司才会选择硬负载，

    更多的公司考虑到成本原因，会选择使用软件负载均衡，它是利用现有的技术结合主机硬件实现的一种消息队列分发机制。
    d.Nginx支持的负载均衡的调度算法方式:
      1）weight轮询（默认）：每个后端服务器都有一个接受请求的权重值（weight），默认情况下权重相同，当调整不
                           同服务器上请求的权重值后，权重大，几率大，权重值主要针对实际工作中不同的后端服务器的
                           硬件配置进行调整的，一般情况下不修改权重，因为一般服务器硬件都是相同的；
      2）ip_hash:按照每个请求ip地址的hash结果分配，这个算法每个ip地址的客户端总会访问同一个服务器，这在一定
                 程度上解决了集群部署环境下的session共享问题；
      3）fair:智能调度算法，动态的根据后端服务器请求处理的响应时间、处理效率来分配请求，结合了以上两种方法的优
              点，但是Nginx默认不支持fair算法，需要安装upstream_fair模块
      4）url_hash : 按照访问的url的hash结果分配请求，每个请求的url会指定后端固定的服务器，当Nginx作为静态服
                    务器时可以提高缓存效率。同样要注意的Nginx默认不支持，需要安装Nginx的hash软件包。
    
### 3.uWSGI-- 一种WSGI容器
	   1）wsgi是一种实现python解析的通用接口标准、协议，实现python web程序与服务器之间交互的通用性，利用wsgi，
              web.py或者django等等开发框架，就可以轻松的部署在不同的web服务器上；
	   2）uwsgi同WSGI一样是一种通信协议，是一个uWSGI服务器自有的协议，它用于定义传输信息的类型，它与WSGI相比是
              两样东西；
	   3）WSGI:在服务器上往往需要跑两个程序，一个是底层的server程序，一个是上层的
              Application,底层的server往往需要处理很多重复性很强，变化不大而又枯燥的工作，WSGI和Gunicorn就
              是一种成熟的解决方案，上层的Application部分，不同的应用差别就很大，无法一劳永逸的解决，但是python
              的web框架flask和django等是一些好的设计模式，server和application的交互，就遵循这个叫WSGI的协议、规范；
	   4）uWSGI是一种python web服务器，实现了uwsgi和WSGI、http等协议的web服务器，负责响应python的web请求，
             因为apache和nginx等，它们自己没有解析动态语言如php的功能，而是分派给其他模块来做，nginx中
             httpuwsgimodule的作用就是与uWSGI服务器进行交互；
### 4.作用：
	1）.虽然nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程，但是在nginx上加上安全性或者其他的
        限制 ，可以达到保护程序的作用；
	2）.uWSGI是内网接口，开启多个work和processes可能也不够用，而nginx可以代理多台uWSGI完成uWSGI的负载均衡；
	3）.django在debug=False下对静态文件的处理能力不是很好，而用nginx来处理更加高效

# 二十一 ： 三次握手，四次挥手 -- TCP
**--> TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，四次挥手关闭一个连接**

### 1.TCP连接：

     一个TCP连接由又一个4元祖构成，分别是两个ip地址和两个端口号，一个TCP连接通常分为三个阶段：启动、数据传输、关闭。
### 2.三次握手（三个报文段）：
    a. 原理：
    为什么要三次握手：客户端和服务端通信前要进行连接，三次握手的作用就是让双方都能明确自己和对方的数据接收和发送能力是否正常
    第一次：客户端发送网络包，服务端收到，这个事件对于服务端来说，可以确认客户端的发送能力，和自己的接受能力正常；
           但是对于客户端，什么都不能确认
    第二次：服务端发包，客户端收到，这样对于客户端来说，可以确认自己的发送和接受能力，也可以确认服务端的
           接收和发送能力是正常的，但是，对于服务端来说，它还是不能确认自己的发送能力和客户端的接受能力是否正常，所以需要第三次握手，即客户端再发包
    第三次：客户端再次发包，服务端收到，这样对于服务端来说就可以确认自己的发送和客户端的接收能力是正常的，
           所以，经过以上三次握手，双方都能分别确认对方和自己的发送、接收功能正常，之后就可以正常通信了。

    b. 具体实现：
    第一次：客户端发送一个SYN创建一个连接，序号设定为随机数A；
    第二次：服务端回应一个SYN/ACK,ACK的确认码为A+1，SYN/ACK;
    第三次：客户端再发送一个ACK，，服务端收到这个ACK，完成三次握手，进入连接创建状态，此时包序号被设定为
           收到的确认号A+1，而响应则为B+1；
### 3.四次挥手（四个报文段）：
**中断连接可以是客户端也可以是服务端，但是原理都一样**

	客户端中断连接的四次握手：
	     第一次：客户端发送一个数据分段，其中的FIN标记设置为1，客户端进入FIN-WAIT状态（只接受不发送数据）；
	     第二次：服务端接收到FIN=1数据分段，发送带有ACK=1的剩余数据分段，确认收到客户端发来的FIN信息；
	     第三次：服务器等到所有数据传输结束，先客户端发送一个带有FIN=1的数据分段，并进入CLOSE-WAIT状态，等
	            待客户端发来带有ACK=1的确认报文；
	     第四次：客户端收到服务器发来带有FIN=1的报文，返回 ACK=1的报文确认，为了防止服务端未收到需要重发，
	            进入TIME-WAIT状态，服务器接收到报文后关闭连接，客户端等待2MSL后未收到回复，则认为服务器
	            成功关闭，客户端也关闭连接。

# 二十 ： 操作系统的五大管理功能 ：
	1.设备管路：主要是负责内核与外围设备的数据交互，实质是对硬件设备的管理，包括对输出输入设备的分配，初始化，维护与回收等，比如管理音频的输入输出；
	2.作业管理：这部分功能主要是负责人机交互，图形界面或者系统任务的管理；
	3.文件管理：这部分功能设计文件的逻辑组织和物理知识，目录结构和管理等；
    4.进程管理：说明一个进程存在的唯一标志是pcd（进程控制块），负责维护进程的信息和状态；
    5.存储管理：数据的存储方式和组织结构。

# 十九 : eval()函数 -- 将字符串转成代码，来执行 ：

	比如：a = '1+2'
	     print(a)
	     输出结果： '1+2'
	
	     a = '1+2'
	     print(eval(a))
	     输出结果： 3

# 十八 ： SQL注入攻击 
 --> 用户在客户端输入特定的字符串提交服务器，在服务器执行sql语句时，将用户输入的特定字符串误以为是sql语句并且执行语句

如何防御sql注入攻击：

	1.项目上线时，将网页错误提示返回信息关闭，或者重写（python中配置：debug=False）,这种方法只是简单的掩盖代码缺陷，并不能防御;
	2.检查变量数据类型和格式；
	3.过过滤字符串；
	4.绑定变量，使用预编译语句；
	5.数据库信息加密；
    6.使用数据库存储过程；
# 十七 ：python对象：
**--> python是基于C语言开发，面向对象的动态语言，对于对象有一种通俗的说法，叫做万物皆对象，意思就是构造的任何数据类型都是一个对象，数字，字符串，函数，甚至是python模块都当做是对象处理**
## 1. 对象的三个属性：身份、类型和值
**object是所有类的基类，在object中定义了对象就有这三个属性**
    身份：也就是id   --> id(对象)   身份是对象的唯一标识
    类型：也就是数据类型 --> type(对象) 决定了该对象可以保存什么类型的值
    值： 也就是对象对应的值 --> print(对象) 就是该对象表示的值
    注意： 每个对象都会记录着引用自己的对象的个数，即引用计数，
          并且有一个或多个“Bases”（One or more bases）：不是所有对象都有Bases，但一些特殊的对象会有，比如：类。
          Bases类似于面向对象语言中的“基类”，“超类”，对象的名字和对象的这三个属性是没有存储在一个地址的。
    查看引用计数：导入sys模块，使用gettrefcount(对象)，由于这个本身也是一个应用，所以这个对象引用计数结果一定大于1。
## 2. 可变和不可变对象：
    可变对象：列表、字典、集合
          所谓可变，即对象的值可变，身份不可变
    可变对象（即数据类型）的拷贝： 可变对象的拷贝，会在内存中开辟一个新的空间来保存拷贝的数据，也就是说创建了与之前不同的引用，当再改变之前的对 
         象时，对拷贝之后的对象没有任何影响；
    不可变对象： 数字、字符串、元祖
          身份和值都不可变，新创建的对象被关联到原来的变量名，旧对象被丢弃，垃 
          圾回收器会在适当的时候回收这些对象（清理内存）
    不可变对象（即数据类型）的拷贝：只在修改的时候才会在内存中开辟新的空 
         间 ，而拷贝则是让多个对象指向同一个引用，这个引用并没有改变，相当于给 
         对象赋值（给新对象一个相同的引用）；
## 3. 引用（实质就是内存中的一个数字地址编号）：
         在python中，每个对象都会在内存中申请开辟一块空间来保存该对象，该对象 
         在内存中所在位置的地址被称为引用，开发程序时，创建的变量名实际就是对 象的地址引用
 **注意：在python中变量就是地址的一种变现形式，并不开辟存储空间**
# 十六： copy和deepcopy（结合可变和不可变数据类型）：
    浅拷贝copy() -- 
           只是将指定对象中的所有引用拷贝了一份，如果这些引用中包含了一些可变对 
          象，那么改变被拷贝对象中的可变对象（列表、字典、集合等），这个新拷贝的对象一样会改变，这种  方式 通常叫做只拷贝顶层引用；
    深拷贝deepcopy() -- 
          深拷贝会逐层进行拷贝，知道拷贝的对象所有引用都是不可变（例如数字、字符串、元祖等）引用为止。

# 十五： python内存管理机制
**python中万物皆对象，每个对象包括自己的引用计数和存储的数据两个部分，所以python内存管理机制是引用计数为主，分代回收机制为辅**

### 1. 引用计数机制：
    利用引用计数方法，在检测到对象引用计数为0时，会直接释放该
	对象的内存空间，这样的优点有：高效、实时性（而非特定时机）、对象有确定的生命
	周期、容易实现；当然缺点也很明显：维护引用计数消耗资源、无法解决循环引用问题，所以需要分代回收辅助；
    
### 2. 标记-清除方法：
         回收时将待回收对象分为两组，一组叫存活组，一组叫死亡组，把各个对象的引用计数复制一
         份出来，对这个副本进行引用环的摘除，摘除完成后，将引用计数不为0的放在存活组，将为0的
         放在死亡组，如果此时将死亡组的对象删除，那么有可能存在存活组的对象引用的对象被删除，
         出现悬空引用的问题，为了解决这个问题，python会对存活组中的对象分析一遍，将他所引用的对象
         从死亡组中解救出来，最后，将在死亡组的所有对象删除
### 3. 分代回收机制：
    由于循环引用问题只会存在于容器类型对象，python会使用双向链表对这
	些对象进行引用，针对每一个对象a，找到a引用的对象b，将对象b的引用计数减一，如果对象引用计数为0，说明是循环引用，对
    其进行销毁，释放内存空间；这个过程很繁琐，为了提高性能，采用分代回收，python默认了三代对象回收机制，回收机制的具体
    方法就是标记清除方法，刚创建的对象默认都是0代对象，当创建的对象和释放的对象之间的差值达到设定的回收阈值上限
    （默认是700个对象），启动回收机制，每次创建新对象都会检查这个差值，当对0代对象进行回收后，未被回收的对象放入
     1代对象集合，当1代达到阈值，也回收，以此类推，python默认是每10次0代回收机制会同时回
    收1代和2代回收，每10次1代回收，会触发1次2代回收，垃圾回收的频率随着对象的存活时间变长而降低，
    2代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内


# 十四： python容器类型（即数据类型）
## 1. 列表（list） --  可变，有序  --  中括号[]
		  a.获取元素 -  通过下标获取元素
		  b.增删改
		     增 ： append ,insert , extend
		     删除：remove , del ,pop ，clear
		     改 ： 列表[下标] =  新值
		  c. 相关运算 ：+ ，* ，in /not in ,len() ,list() ,max() ,min()

### 列表1.append（a） 和列表1.extend（a）的区别： 

          append: 添加对象到列表1（将添加的对象作为列表1的一个元素）
          extend: 添加元素到列表1（将添加的对象中的元素添加到列表1）
					a =  [1,2,3,4]      
					b =  [5,6,7,8]
					a.append(b)   # a: [1,2,3,4,[5,6,7,8]]
                    a =  [1,2,3,4] 
                    a.extend(b)  # a: [1,2,3,4,5,6,7,8]			

### 将[[1,2],[3,4],[5,6]]一行代码展开该列表,得出[1,2,3,4,5,6]
			a= [[1, 2], [3, 4], [5, 6]]
			b= [j for i in a for j in i]
## 2. 元祖（tuple） --  不可变，有序  --   小括号()
             注意： 当元祖只有一个元素时，要加逗号
                   a = (1)  ---   a变量类型是int类型
                   b = (1,)  ---  b变量类型是tuple类型

			  获取元素 -  通过下标获取元素
			              变量1，变量2 = （元素1，元素2）
			              变量1，*变量2 = （元素1，元素2，元素3......）
			  相关运算 ：+ ，* ，in /not in ,len() ,tuple() ,max() ,min()
## 3.  字典 （dict） --  可变，有序  --  大括号{}
			   a.获取元素  -- 通过键获取元素
			   b.增删改
			   增  ： 字典[key] = 值 ， 字典1.update（字典2）， 字典1.setdefault(key,值)
			   删  ：  del  字典[key]，字典.pop(key) ，clear
			   改  ：字典[key]  = 值
			   c. 相关运算 ：in /not in ,len() ,dict() ,
			          max() : 取的是字典的key的最小值 ,key类型需要一样
			          min() ：取的是字典的key的最小值 ,key类型需要一样
## 4. 集合 （set)  --  可变、无序  --大括号{}
              a. 查--获取集合元素 ： 不能单独获取某个元素，只能遍历
			  b. 增 （添加元素）： 集合.add(元素) --  将制定元素添加到集合中
			                  集合.update(序列) --  将序列中的元素添加到集合中（序列中的元素必须是不可变的）
			  c. 删 （删除元素）：  集合.remove(元素)   --  删除集合中指定的元素
			  d.   in / not in  ,max ,min, len ,set
              e.数学运算：包含（>=,<=）,并集（|）,交集（&），补集（^）,差集（-）

## 5. 字符串（str）-- 不可变、 有序--两个单引号''或者双引号
          a.获取元素  -- 通过下标获取元素
          b. 字符串切片：字符串1[:] 
          c. 相关运算 ：+ ，* ，in /not in ,len() ,str() ,max() ,min()
          d.转义字符：\n,\t,\',\
          e.阻止转义：r/R
       
# 十三：python中的三目运算符： 
      python中的三目运算符：  值1  if  条件语句 else 值2 
       条件语句为真，结果为值1，否则为值2  -->  max = x if x >= y else y

# 十二： 随机数：
    0-1随机小数：random.random(),括号中不传参
    0到40随机整数： random.randint(0,40) 
    随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数
# 十一 ： Django中间件：
**中间件是一个用来处理django的响应与请求的框架级别的钩子，它是一个青年，低级别的插件系统，用于在全局范围内改变django的输入输出，每个中间件组件都负责做一些特定的功能**
### a. 如何自定义中间件：
	  1. 写一个中间件类，要继承MIDDLEWAREMIXIN类；
	  2. 重写父类中响应的中间件方法；
	  3. 将自定义的类名添加配置到setting.py文件的MIDDLEWARE配置中；
### b. 根据需求重写父类的对象方法：

中间件中可以定义五个方法：

##### (1)def process_request(self,request)  # 视图函数之前执行
       
         返回值可以是none也可以是httpresponse对象，返回none，就按照正常流程走，交给下个中间件处理，
         返回httpresponse对象，django将不执行后面的中间件，也不执行视图函数，直接执行当前中间件的process_response;
         有多个中间件会按照MIDDLEWARE中注册顺序依次执行；
##### (2)def process_view(self,request,view_func,*args,**kwargs)  # process_response之后，视图函数之前执行
         返回值None，就正常执行;
         返回response对象，不执行后面的process_view和视图，直接执行所有中间件的process_response;
         有多个中间件会按照MIDDLEWARE中注册顺序依次执行； 
##### (3)def process_template_response(self,request,response)  # 在视图函数之后，process_response之前执行
		触发条件 -- 只有视图函数return中有render方法才触发此方法，
		返回response对象；
        多个中间件时，按照注册的倒序执行，执行完所有的process_template_response方法后执行response.render方法
##### (4)def process_exception(self,request,exception)  # 在视图函数之后，process_response之前执行
        触发条件 -- 只有出现异常才会出发该方法；
		返回None，表示不对错误进行处理，交给下一个中间件处理；
		返回response对象，表示下一个中间件的process_exception不执行，直接执行所有中间件的process_response方法；
		多个中间件时，按照注册的倒序执行；
##### (5)def process_response(self,request,response) # 视图函数之后
          返回值必须是httpresponse对象（可以直接返回response），
          有多个中间件时，按照注册的倒序执行

### c. 使用场景：
	（1） 缓存 -- 中间件去缓存看看有没有数据，有直接返回，没有再执行业务逻辑；
	（2） IP限制 -- 阻止特定的IP访问，或者设置单位时间内访问url的次数；
	（3） url访问过滤 -- 项目中有些url需要登录才能访问，可以在中间件写登录状态校验



# 十： 元素是列表的列表
			     a = [[]] * 10
			     a[0].append(10)
			     print(a)
          结果：[[10],[10],[10],[10],[10],[10],[10],[10],[10],[10]]

     如果只想给a[0]添加值，可以用列表解析式  
			 a = [ [] for _ in range(5)]
			 a[0].append(5)
			 print(a)
			 结果：[[5],[],[],[],[]]
# 九： GIL（全局解释器锁）对python多线程性能的影响：
**某种情况下（线程串行）上来说会降低python性能**

	GIL是Python为了保证线程安全而采取的让线程独立运行的限制,一个核只能在同一时间运行
    一个线程，也就是说同一进程中假如有多个线程，一个线程在运行python程序时会霸占python
    解释器（GIL锁的功能），使该进程内的其他线程无法运行，如果线程运行过程中遇到耗时操
    作，则解释器锁解开，使其他线程运行，所以在多线程中，线程的运行仍是有先后顺序的，并
    不是同时进行；

    多线程优缺点：
	对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几
    乎占不到任何优势，还有可能因为争夺资源而变慢；

	多进程优缺点：
	解决办法就是多进程和协程(协程也只是单CPU,但是能减小切换代价提升性能)，多进程中因为
    每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现
    多个进程的同时运行，缺点是进程系统资源开销大。

# 八： 闭包问题  （变量作用域）
### 1. python属性查找规则：LEGB
		1. （Local）局部作用域，每当调用一个函数的时候就创建了一个局部作用域，它最先被搜索。 
		2. （Enclosing）嵌套的父级函数的局部作用域 
		3. （global）全局作用域 
		4. （built-in）内建作用域，这个是内建函数和类的作用域。

### 2.	 实列：
		1）	 def func(x):
		        a = []
		        for i in range(5):
		            a.append(i*x)
		        return a
		     b = func(2)
		     print(b)
       

        输出结果为：[0, 2, 4, 6, 8]

      2）
		def func():
		   return [lambda x : i * x for i in range(4)]
		
		print([m(2) for m in func()])
        
        输出结果为： [6, 6, 6, 6]
        如果想得到[0,2,4,6]可以用生成器或者创建闭包或者偏函数

        生成器
        def multipliers():
              for i in range(4): yield lambda x : i * x
        print([m(2) for m in multipliers()])

        将闭包作用域变为局部作用域
        def multipliers():
              return [lambda x，i=i : i * x for i in range(4)]
        print([m(2) for m in multipliers()])

        偏函数
		from functools import partial
		from operator import mul
		
		def multipliers():
		  return [partial(mul, i) for i in range(4)]
        print([m(2) for m in multipliers()])

# 七： 映射（map()） --  归纳（reduce()） -- 过滤（filter()） -- 
#   解析式生成可迭代对象:列表解析式，元祖解析式，字典解析式等（任何可迭代对象）

	1） map(函数，可迭代序列对象) -- 对可迭代对象的每个元素执行函数，返回一个序列对象（需要指定保存类型则：list(map())） <--> （数据处理）

	2) reduce(函数，可迭代对象) -- 通常map和reduce都是在列表里结合使用，map对数据进行一一映射处理，reduce对数据进行整合计算 <-->（数据整合）

	3） filter（函数，可迭代对象） --  将可迭代对象的元素中满足函数的保留下来，不满足的剔除掉 <-->（数据筛选）

	4） 解析式是python生成列表的一种高效方式（也可以生成其他类型，通常生成list） ： 列表解析式 -- [ function for item in iterable] 
	
	   比如 ： [ x * x for x in range(1,5)]
	          [ num * num for num in range(-8,5) if num < 0]

    字典解析式：
	# Taken from page 70 chapter 3 of Fluent Python by Luciano Ramalho
	
	DIAL_CODES = [
	    (86, 'China'),
	    (91, 'India'),
	    (1, 'United States'),
	    (62, 'Indonesia'),
	    (55, 'Brazil'),
	    (92, 'Pakistan'),
	    (880, 'Bangladesh'),
	    (234, 'Nigeria'),
	    (7, 'Russia'),
	    (81, 'Japan'),
	    ]
	
	>>> country_code = {country: code for code, country in DIAL_CODES}
	>>> country_code
	{'Brazil': 55, 'Indonesia': 62, 'Pakistan': 92, 'Russia': 7, 'China': 86, 'United States': 1, 'Japan': 81, 'India': 91, 'Nigeria': 234, 'Bangladesh': 880}
	>>> {code: country.upper() for country, code in country_code.items() if code < 66}
	{1: 'UNITED STATES', 7: 'RUSSIA', 62: 'INDONESIA', 55: 'BRAZIL'}

	集合解析式：
	
	# taken from page 87, chapter 3 of Fluent Python by Luciano Ramalho
	
	>>> from unicodedata import name
	>>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
	{'×', '¥', '°', '£', '', '#', '¬', '%', 'µ', '>', '¤', '±', '¶', '§', '<', '=', '', '$', '÷', '¢', '+'}

# 六: 分布式、高并发
# 五： 字符串格式化-- format函数 （菜鸟教程）

功能： a.代替占位符： f'{a}任意字符{b}' -- 等同于--> '%s任意字符%s' %(a,b)
      b.格式化字符串：'{a}{b}'.format(a='内容'，b='内容')

实列：

    1.传入参数：
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
	 
	print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))
	 
	# 通过字典设置参数
	site = {"name": "菜鸟教程", "url": "www.runoob.com"}
	print("网站名：{name}, 地址 {url}".format(**site))
	 
	# 通过列表索引设置参数
	my_list = ['菜鸟教程', 'www.runoob.com']
	print("网站名：{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的

    2.传入对象
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
	 
	class AssignValue(object):
	    def __init__(self, value):
	        self.value = value
	my_value = AssignValue(6)
	print('value 为: {0.value}'.format(my_value))  # "0" 是可选的
    3.格式化数字：
	>>> print("{:.2f}".format(3.1415926));
	3.14

# 四： 四种典型数据结构 -- 堆栈、队列、线性表/顺序表、链表
### 1. 堆栈（Stack，就是栈的别名） -- 先进后出(FILO) -- 
    类似往杯子里苹果，先放进去的要后拿出来，放进去的动作叫压栈，拿出来叫弹栈
    a. 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数名，局部变量的名等。其操作方式类
          似于数据结构中的栈，只能在栈顶做插入和删除操作。
    b. 堆区（heap）— 由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
       python实现堆栈结构的代码放在github:https://github.com/luoshuxiao/basic-python-/tree/master/python%E5%AE%9E%E7%8E%B0%E5%85%B8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84
		

### 2. 队列 (QUEUE)  -- 先进先出(FIFO) --
    类似超市排队结账，先排先结账，后排对的后结账，队列只能在队头做删除操作,在队尾做插入操作
### 3. 线性表/顺序表（List/SequenceList）-- 
    连续存放，用索引定位元素（类似python中的list）
    缺点：当插入或者删除、添加操作等，性能较差，比如插入时，后面的元素都要往后挪动，
         后面的元素越多，性能越差；
    优点：元素由索引定位，定位速度很快
### 4. 链表（LinkedList） -- head ->(D,N) ->(D,N) ->(D,N) ->(D,N) ...-> 空  
 **其中D表示Data,N表示Next,两个一起表示一个Node节点 （每个指针指向下一个节点）**

    优点： 增加、删除节点等效率比线性表高很多，只需要对指针做更改，不需要对后面的节点做更改
    缺点： 定位元素时只能拿到头head，要遍历，没有线性表速度快
    python实现链表数据结构放在github:https://github.com/luoshuxiao/basic-python-/tree/master/python%E5%AE%9E%E7%8E%B0%E5%85%B8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84
		

# 三：  装饰器：一个闭包，把一个函数当做参数返回 一个替代版的函数，本质上就是一个返回函数的函数 (被装饰的函数名会变成装饰器的名字，不在是原来的名字)

		装饰器的三个要素（）：
		 
		1. 外层函数嵌套内层函数
		2. 外层函数返回内层函数
		3. 内层函数调用外层函数参数
		
		#  对要装饰的函数添加新的代码
		def outer(func):
		    def inner(*args, **kwargs):
                    # 需要装饰的代码（在func基础上添加的新代码）
		            return func(*args, **kwargs)
		    return inner
# 二： 偏函数：把一个函数的某些参数固定住（设默认值），返回一个新的函数

    列子：

	int('234') -- 将'234'字符串变成int类型 --int('234', base=10)将字符串引号去掉后，当成10进制的数，然后转换成10进制数返回
	int('1010',base=2) -- 将字符串去掉引号后当成一个2进制数来算，转成10进制数返回
    
    自定义偏函数：

    导入偏函数模块：from functools import partial
    int2 = partial(int, base=2)
    int2就是一个偏函数 
       -- int2('101011')--将101011当2进制，转换成10进制数


# 一： 网络传输协议：

**OSI（open system interconnection）七层模型 、协议，由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定**

	第七层--应用层：各种应用程序协议，如HTTP/FTP/SMTP/POP3；
	第六层--表示层：信息的语法语义以及他们的关联，如数据格式化、加密、解密、转换翻译、压缩解压缩等；
	第五层--会话层：不同机器上的用户之间建立、管理会话；
	第四层--传输层：接受上一层的数据，提供端对端的接口，必要的时候进行分割，并将数据交给网络层，且保证
                   数据段有效到达；（TCP/UDP）
	第三层--网络层：控制子网的运行。为数据包选择路由，如逻辑编址，分组传输、路由选择等； 
	第二层--数据链路层：物理寻址，同时将原始比特流转变为逻辑传输线路
	第一层--物理层：机械、电子、定时接口通信信道上的原始比特流传输，以二进制数据形式在物理介质上传输数据


	   物理层：
			主要功能是利用传输介质为数据链路层提供物理连接，以实现相邻计算机节点之间比特流的透明传输（指比特
            流经实际电路传送前后无变化，不受电路影响，当电路透明不存在），尽可能屏蔽掉具体的传输介质和物理设备
            差异，让上层数据链路层不必考虑传输介质带来的影响。
	
	   数据链路层：
			由于计算机网路中存在各种干扰，物理链路不可靠，这一层在物理层提供的比特流基础上，负责建立和管理节点
            间链路，通过各种控制协议（差错控制，流量控制方法等）解决同一网络节点之间的通信，将有差异的物理信道
            变为无差错的，能可靠传输数据帧的数据链路，即提供可靠的通过物理介质传输数据的方法，通常分MAC/LLC两
            层。（局域网内）
	
	   网络层：
			OSI模型中最复杂的一层，通信子网最高的一层，通过路由选择算法为报文或分组选择最适当的路径，数据链路
            的数据在网络层被转换成数据包，通过路径选择、分组组合、进/出路由等控制，将信息从一个网路设备传到另
            一个网络设备，解决不同子网间的通信。（各局域网之间）
	   
	   传输层：
			上三层的主要功能数数据处理，传输层主要是数据通信，是通信子网和资源子网的接口和桥梁，可靠传输（TCP）
            在必要时对数据 进行分割，传输到网络层，确保数据正确无误的传输到网络层，目标设备在指定时间内没有确认
            收到，数据将被重发，而不可靠传输（UDP）则只负责发送，不确保目标设备是否收到。
	   
	   会话层：
			用户应用程序和网络之间的接口，通过远程地址（为用户设计的域名），建立、组织、协调两个会话进程之间的
            通信，对数据交换进行管理
	   
	   表示层 ：
			对应用层的数据进行解释，格式化，压缩和解压，加密和解密等
	
	   应用层：
			模型的最高层，直接向用户提供服务，是用户与网络以及应用程序和网络间的直接接口，使的用户能够与网络进
            行交互式联系，该层的应用程序实现用户请求的服务，应用层为用户提供：文件服务、目录服务、文件传输服
            务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据
            库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实
            现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的