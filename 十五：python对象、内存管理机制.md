# 一 ：python对象：
**--> python是基于C语言开发，面向对象的动态语言，对于对象有一种通俗的说法，叫做万物皆对象，意思就是构造的任何数据类型都是一个对象，数字，字符串，函数，甚至是python模块都当做是对象处理**
## 1. 对象的三个属性：身份、类型和值
**object是所有类的基类，在object中定义了对象就有这三个属性**

    身份：也就是id   --> id(对象)   身份是对象的唯一标识
    类型：也就是数据类型 --> type(对象) 决定了该对象可以保存什么类型的值
    值： 也就是对象对应的值 --> print(对象) 就是该对象表示的值
    注意： 每个对象都会记录着引用自己的对象的个数，即引用计数，
          并且有一个或多个“Bases”（One or more bases）：不是所有对象都有Bases，但一些特殊的对象会有，比如：类。
          Bases类似于面向对象语言中的“基类”，“超类”，对象的名字和对象的这三个属性是没有存储在一个地址的。
    查看引用计数：导入sys模块，使用gettrefcount(对象)，由于这个本身也是一个应用，所以这个对象引用计数结果一定大于1。
## 2. 可变和不可变对象：
    可变对象：列表、字典、集合
          所谓可变，即对象的值可变，身份不可变
    可变对象（即数据类型）的拷贝： 可变对象的拷贝，会在内存中开辟一个新的空间来保存拷贝的数据，也就是说创建了与之前不同的引用，当再改变之前的对 
         象时，对拷贝之后的对象没有任何影响；
    不可变对象： 数字、字符串、元祖
          身份和值都不可变，新创建的对象被关联到原来的变量名，旧对象被丢弃，垃 
          圾回收器会在适当的时候回收这些对象（清理内存）
    不可变对象（即数据类型）的拷贝：只在修改的时候才会在内存中开辟新的空 
         间 ，而拷贝则是让多个对象指向同一个引用，这个引用并没有改变，相当于给 
         对象赋值（给新对象一个相同的引用）；
## 3. 引用（实质就是内存中的一个数字地址编号）：
         在python中，每个对象都会在内存中申请开辟一块空间来保存该对象，该对象 
         在内存中所在位置的地址被称为引用，开发程序时，创建的变量名实际就是对 象的地址引用
 **注意：在python中变量就是地址的一种变现形式，并不开辟存储空间**
# 二： copy和deepcopy（结合可变和不可变数据类型）：
    浅拷贝copy() -- 
           只是将指定对象中的所有引用拷贝了一份，如果这些引用中包含了一些可变对 
          象，那么改变被拷贝对象中的可变对象（列表、字典、集合等），这个新拷贝的对象一样会改变，这种  方式 通常叫做只拷贝顶层引用；
    深拷贝deepcopy() -- 
          深拷贝会逐层进行拷贝，知道拷贝的对象所有引用都是不可变（例如数字、字符串、元祖等）引用为止。

# 三： python内存管理机制
**python中万物皆对象，每个对象包括自己的引用计数和存储的数据两个部分，所以python内存管理机制是引用计数为主，分代回收机制为辅**

### 1. 引用计数机制：
    利用引用计数方法，在检测到对象引用计数为0时，会直接释放该
	对象的内存空间，这样的优点有：高效、实时性（而非特定时机）、对象有确定的生命
	周期、容易实现；当然缺点也很明显：维护引用计数消耗资源、无法解决循环引用问题，所以需要分代回收辅助；
    
### 2. 标记-清除方法：
         回收时将待回收对象分为两组，一组叫存活组，一组叫死亡组，把各个对象的引用计数复制一
         份出来，对这个副本进行引用环的摘除，摘除完成后，将引用计数不为0的放在存活组，将为0的
         放在死亡组，如果此时将死亡组的对象删除，那么有可能存在存活组的对象引用的对象被删除，
         出现悬空引用的问题，为了解决这个问题，python会对存活组中的对象分析一遍，将他所引用的对象
         从死亡组中解救出来，最后，将在死亡组的所有对象删除
### 3. 分代回收机制：
    由于循环引用问题只会存在于容器类型对象，python会使用双向链表对这
	些对象进行引用，针对每一个对象a，找到a引用的对象b，将对象b的引用计数减一，如果对象引用计数为0，说明是循环引用，对
    其进行销毁，释放内存空间；这个过程很繁琐，为了提高性能，采用分代回收，python默认了三代对象回收机制，回收机制的具体
    方法就是标记清除方法，刚创建的对象默认都是0代对象，当创建的对象和释放的对象之间的差值达到设定的回收阈值上限
    （默认是700个对象），启动回收机制，每次创建新对象都会检查这个差值，当对0代对象进行回收后，未被回收的对象放入
     1代对象集合，当1代达到阈值，也回收，以此类推，python默认是每10次0代回收机制会同时回
    收1代和2代回收，每10次1代回收，会触发1次2代回收，垃圾回收的频率随着对象的存活时间变长而降低，
    2代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内
