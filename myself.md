

# 二十 ： 三次握手，四次挥手 -- TCP
**--> TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，四次挥手关闭一个连接**

###1.TCP连接：

     一个TCP连接由又一个4元祖构成，分别是两个ip地址和两个端口号，一个TCP连接通常分为三个阶段：启动、数据传输、关闭。
###2.三次握手（三个报文段）：

    为什么要三次握手：客户端和服务端通信前要进行连接，三次握手的作用就是让双方都能明确自己和对方的数据接收和发送能力是否正常
    第一次：客户端发送网络包，服务端收到，这个事件对于服务端来说，可以确认客户端的发送能力，和自己的接受能力正常；
          但是对于客户端，什么都不能确认
    第二次：服务端发包，客户端收到，这样对于客户端来说，可以确认自己的发送和接受能力，也可以确认服务端的接收和发送能力是正常的，但是，对于服务端来说，它还是不能确认自己的发送能力和客户端的接受能力是否正常，所以需要第三次握手，即客户端再发包
    第三次：客户端再次发包，服务端收到，这样对于服务端来说就可以确认自己的发送和客户端的接收能力是正常的，
    所以，经过以上三次握手，双方都能分别确认对方和自己的发送、接收功能正常，之后就可以正常通信了。
###3.四次挥手（四个报文段）：
     



# 十九 ： 操作系统的五大管理功能 ：
	1.设备管路：主要是负责内核与外围设备的数据交互，实质是对硬件设备的管理，包括对输出输入设备的分配，初始化，维护与回收等，比如管理音频的输入输出；
	2.作业管理：这部分功能主要是负责人机交互，图形界面或者系统任务的管理；
	3.文件管理：这部分功能设计文件的逻辑组织和物理知识，目录结构和管理等；
    4.进程管理：说明一个进程存在的唯一标志是pcd（进程控制块），负责维护进程的信息和状态；
    5.存储管理：数据的存储方式和组织结构。

# 十八 : eval()函数 -- 将字符串转成代码，来执行 ：

	比如：a = '1+2'
	     print(a)
	     输出结果： '1+2'
	
	     a = '1+2'
	     print(eval(a))
	     输出结果： 3

# 十七 ： SQL注入攻击 
 --> 用户在客户端输入特定的字符串提交服务器，在服务器执行sql语句时，将用户输入的特定字符串误以为是sql语句并且执行语句

如何防御sql注入攻击：

	1.项目上线时，将网页错误提示返回信息关闭，或者重写（python中配置：debug=False）,这种方法只是简单的掩盖代码缺陷，并不能防御;
	2.检查变量数据类型和格式；
	3.过过滤字符串；
	4.绑定变量，使用预编译语句；
	5.数据库信息加密；

#十六 ：python对象：
**--> 在python中，对对象有一种通俗的说法，叫做万物皆对象，意思就是构造的任何数据类型都是一个对象，数字，字符串，函数，甚至是模块python都当做是对象处理**
## 1. 对象的三个属性：身份、类型和值
    身份：也就是id   --> id(对象)   身份是对象的唯一标识
    类型：也就是数据类型 --> type(对象) 决定了该对象可以保存什么类型的值
    值： 也就是对象对应的值 --> print(对象) 就是该对象表示的值
##2. 可变和不可变对象：
    可变对象：列表、字典、集合
          所谓可变，即对象的值可变，身份不可变
    可变对象（即数据类型）的拷贝： 可变对象的拷贝，会在内存中开辟一个新的空间来保存拷贝的数据，也就是说创建了与之前不同的引用，当再改变之前的对 
         象时，对拷贝之后的对象没有任何影响；
    不可变对象： 数字、字符串、元祖
          身份和值都不可变，新创建的对象被关联到原来的变量名，旧对象被丢弃，垃 
          圾回收器会在适当的时候回收这些对象（清理内存）
    不可变对象（即数据类型）的拷贝：只在修改的时候才会在内存中开辟新的空 
         间 ，而拷贝则是让多个对象指向同一个引用，这个引用并没有改变，相当于给 
         对象赋值（给新对象一个相同的引用）；
##3. 引用（实质就是内存中的一个数字地址编号）：
         在python中，每个对象都会在内存中申请开辟一块空间来保存该对象，该对象 
         在内存中所在位置的地址被称为引用，开发程序时，创建的变量名实际就是对 象的地址引用
 **注意：在python中变量就是地址的一种变现形式，并不开辟存储空间**
#十五： 深拷贝和浅拷贝（结合可变和不可变数据类型）：
    浅拷贝copy() -- 
           只是将指定对象中的所有引用拷贝了一份，如果这些引用中包含了一些可变对 
          象，那么改变被拷贝对象中的可变对象（列表、字典、集合等），这个新拷贝的对象一样会改变，这种  方式 通常叫做只拷贝顶层引用；
    深拷贝deepcopy() -- 
          深拷贝会逐层进行拷贝，知道拷贝的对象所有引用都是不可变（例如数字、字符串、元祖等）引用为止。

# 十四： python容器类型（即数据类型）
##1. 列表（list） --  可变，有序  --  中括号[]
		  a.获取元素 -  通过下标获取元素
		  b.增删改
		     增 ： append ,insert , extend
		     删除：remove , del ,pop ，clear
		     改 ： 列表[下标] =  新值
		  c. 相关运算 ：+ ，* ，in /not in ,len() ,list() ,max() ,min()

### 列表1.append（a） 和列表1.extend（a）的区别： 

                append是添加元素到列表1（将添加的元素作为整体，列表1的一个元素）
                extend是添加列表到列表1（将添加的元素分开，可以作为列表1的多个元素）
                                            

					a =  [1,2,3,4]
					b =  [5,6,7,8]
					a.append(b)
					print(a)
					a =  [1,2,3,4]
					b =  [5,6,7,8]
					a.extend(b)
					print(a)

### 将[[1,2],[3,4],[5,6]]一行代码展开该列表,得出[1,2,3,4,5,6]
			a= [[1, 2], [3, 4], [5, 6]]
			b= [j for i in a for j in i]
			print(b)
##2. 元祖（tuple） --  不可变，有序  --   小括号()
             注意： 当元祖只有一个元素时，要加逗号
                   a = (1)  ---   a变量类型是int类型
                   b = (1,)  ---  b变量类型是tuple类型


			  获取元素 -  通过下标获取元素
			              变量1，变量2 = （元素1，元素2）
			              变量1，*变量2 = （元素1，元素2，元素3......）
			  相关运算 ：+ ，* ，in /not in ,len() ,tuple() ,max() ,min()
##3.  字典 （dict） --  可变，无序  --  大括号{}
			   a.获取元素  -- 通过键获取元素
			   b.增删改
			   增  ： 字典[key] = 值 ， 字典1.update（字典2）， 字典1.setdefault(key,值)
			   删  ：  del  字典[key]，字典.pop(key)  ，clear
			   改  ：字典[key]  = 值
			   c. 相关运算 ：in /not in ,len() ,dict() ,
			          max() : 取的是字典的key的最小值 ,key类型需要一样
			          min()  ：取的是字典的key的最小值 ,key类型需要一样
##4. 集合 （set)  --  可变、无序  --大括号{}
              a. 查--获取集合元素 ： 不能单独获取某个元素，只能遍历
			  b. 增 （添加元素）： 集合.add(元素) --  将制定元素添加到集合中
			                  集合.update(序列) --  将序列中的元素添加到集合中（序列中的元素必须是不可变的）
			
			  c. 删 （删除元素）：  集合.remove(元素)   --  删除集合中指定的元素
			
			  d.   in / not in  ,max ,min, len ,set

              e.数学运算：包含（>=,<=）,并集（|）,交集（&），补集（^）,差集（-）

##5. 字符串（str）-- 不可变、 有序--两个单引号''
          a.获取元素  -- 通过下标获取元素
          b. 字符串切片：字符串1[:] 
          c. 相关运算 ：+ ，* ，in /not in ,len() ,str() ,max() ,min()
          d.转义字符：\n,\t,\',\
          e.阻止转义：r/R
          
       
#十三：python中的三目运算符： 
      python中的三目运算符：  值1  if  条件语句 else 值2 
       条件语句为真，结果为值1，否则为值2  -->  max = x if x >= y else y

#十二： 随机数：
    0-1随机小数：random.random(),括号中不传参
    0到40随机整数： random.randit(0,40) 
    随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数
#十一.生成器在使用next获取元素之前，必须要调用该生成器函数赋值给一个变量，再next这个变量获取

			def  my_feibo():
			    sum1=sum2=1
			    while True:
			        yield sum1
			        sum1,sum2=sum2,sum1+sum2
			c = my_feibo()    # 先调用生成器函数再用next获取元素
			print(next(c))
#十： 元素是列表的列表
			     a = [[]] * 10
			     a[0].append(10)
			     print(a)
          结果：[[10],[10],[10],[10],[10],[10],[10],[10],[10],[10]]

     如果只想给a[0]添加值，可以用列表解析式  
			 a = [ [] for _ in range(5)]
			 a[0].append(5)
			 print(a)
			 结果：[[5],[],[],[],[]]
#九： GIL（全局解释器锁）对python多线程性能的影响：某种情况下（线程串行）上来说会降低python性能

#八： 闭包问题  （变量作用域）
###1. python属性查找规则：LEGB
		1. （Local）局部作用域，每当调用一个函数的时候就创建了一个局部作用域，它最先被搜索。 
		2. （Enclosing）嵌套的父级函数的局部作用域 
		3. （global）全局作用域 
		4. （built-in）内建作用域，这个是内建函数和类的作用域。

###2.	 实列：
		1）	 def func(x):
		        a = []
		        for i in range(5):
		            a.append(i*x)
		        return a
		     b = func(2)
		     print(b)
       

        输出结果为：[0, 2, 4, 6, 8]

      2）
		def func():
		   return [lambda x : i * x for i in range(4)]
		
		print([m(2) for m in func()])
        
        输出结果为： [6, 6, 6, 6]
        如果想得到[0,2,4,6]可以用生成器或者创建闭包或者偏函数

        生成器
        def multipliers():
              for i in range(4): yield lambda x : i * x
        print([m(2) for m in multipliers()])

        将闭包作用域变为局部作用域
        def multipliers():
              return [lambda x，i=i : i * x for i in range(4)]
        print([m(2) for m in multipliers()])

        偏函数
		from functools import partial
		from operator import mul
		
		def multipliers():
		  return [partial(mul, i) for i in range(4)]
        print([m(2) for m in multipliers()])

#七： 映射（map()） --  归纳（reduce()） -- 过滤（filter()） -- 
#   解析式生成可迭代对象:列表解析式，元祖解析式，字典解析式等（任何可迭代对象）

	1） map(函数，可迭代序列对象) -- 对可迭代对象的每个元素执行函数，返回一个序列对象（需要指定保存类型则：list(map())） <--> （数据处理）

	2) reduce(函数，可迭代对象) -- 通常map和reduce都是在列表里结合使用，map对数据进行一一映射处理，reduce对数据进行整合计算 <-->（数据整合）

	3） filter（函数，可迭代对象） --  将可迭代对象的元素中满足函数的保留下来，不满足的剔除掉 <-->（数据筛选）

	4） 解析式是python生成列表的一种高效方式（也可以生成其他类型，通常生成list） ： 列表解析式 -- [ function for item in iterable] 
	
	   比如 ： [ x * x for x in range(1,5)]
	          [ num * num for num in range(-8,5) if num < 0]

    字典解析式：
	# Taken from page 70 chapter 3 of Fluent Python by Luciano Ramalho
	
	DIAL_CODES = [
	    (86, 'China'),
	    (91, 'India'),
	    (1, 'United States'),
	    (62, 'Indonesia'),
	    (55, 'Brazil'),
	    (92, 'Pakistan'),
	    (880, 'Bangladesh'),
	    (234, 'Nigeria'),
	    (7, 'Russia'),
	    (81, 'Japan'),
	    ]
	
	>>> country_code = {country: code for code, country in DIAL_CODES}
	>>> country_code
	{'Brazil': 55, 'Indonesia': 62, 'Pakistan': 92, 'Russia': 7, 'China': 86, 'United States': 1, 'Japan': 81, 'India': 91, 'Nigeria': 234, 'Bangladesh': 880}
	>>> {code: country.upper() for country, code in country_code.items() if code < 66}
	{1: 'UNITED STATES', 7: 'RUSSIA', 62: 'INDONESIA', 55: 'BRAZIL'}

	集合解析式：
	
	# taken from page 87, chapter 3 of Fluent Python by Luciano Ramalho
	
	>>> from unicodedata import name
	>>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
	{'×', '¥', '°', '£', '', '#', '¬', '%', 'µ', '>', '¤', '±', '¶', '§', '<', '=', '', '$', '÷', '¢', '+'}

#六: 分布式、高并发、多线程
#五： 字符串格式化-- format函数 （菜鸟教程）

功能： a.代替占位符： f'{a}任意字符{b}' -- 等同于--> '%s任意字符%s' %(a,b)
      b.格式化字符串：'{a}{b}'.format(a='内容'，b='内容')

实列：

    1.传入参数：
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
	 
	print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))
	 
	# 通过字典设置参数
	site = {"name": "菜鸟教程", "url": "www.runoob.com"}
	print("网站名：{name}, 地址 {url}".format(**site))
	 
	# 通过列表索引设置参数
	my_list = ['菜鸟教程', 'www.runoob.com']
	print("网站名：{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的

    2.传入对象
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
	 
	class AssignValue(object):
	    def __init__(self, value):
	        self.value = value
	my_value = AssignValue(6)
	print('value 为: {0.value}'.format(my_value))  # "0" 是可选的
    3.格式化数字：
	>>> print("{:.2f}".format(3.1415926));
	3.14
#四： 索引、二叉树、内存管理机制、堆排序

#三：  装饰器：一个闭包，把一个函数当做参数返回 一个替代版的函数，本质上就是一个返回函数的函数 (被装饰的函数名会变成装饰器的名字，不在是原来的名字)

		装饰器的三个要素（）：
		 
		1. 外层函数嵌套内层函数
		2. 外层函数返回内层函数
		3. 内层函数调用外层函数参数
		
		#  对要装饰的函数添加新的代码
		def outer(func):
		    def inner(*args, **kwargs):
                    # 需要装饰的代码（在func基础上添加的新代码）
		            return func(*args, **kwargs)
		    return inner
#二： 偏函数：把一个函数的某些参数固定住（设默认值），返回一个新的函数

    列子：

	int('234') -- 将'234'字符串变成int类型 --int('234', base=10)将字符串引号去掉后，当成10进制的数，然后转换成10进制数返回
	int('1010',base=2) -- 将字符串去掉引号后当成一个2进制数来算，转成10进制数返回
    
    自定义偏函数：

    导入偏函数模块：from functools import partial
    int2 = partial(int, base=2)
    int2就是一个偏函数 
       -- int2('101011')--将101011当2进制，转换成10进制数


#一： 网络传输协议：

**OSI（open system interconnection）七层模型 、协议，由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定**

	第七层--应用层：各种应用程序协议，如HTTP/FTP/SMTP/POP3；
	第六层--表示层：信息的语法语义以及他们的关联，如数据格式化、加密、解密、转换翻译、压缩解压缩等；
	第五层--会话层：不同机器上的用户之间建立、管理会话；
	第四层--传输层：接受上一层的数据，提供端对端的接口，必要的时候进行分割，并将数据交给网络层，且保证
                   数据段有效到达；（TCP/UDP）
	第三层--网络层：控制子网的运行。为数据包选择路由，如逻辑编址，分组传输、路由选择等； 
	第二层--数据链路层：物理寻址，同时将原始比特流转变为逻辑传输线路
	第一层--物理层：机械、电子、定时接口通信信道上的原始比特流传输，以二进制数据形式在物理介质上传输数据


	   物理层：
			主要功能是利用传输介质为数据链路层提供物理连接，以实现相邻计算机节点之间比特流的透明传输（指比特
            流经实际电路传送前后无变化，不受电路影响，当电路透明不存在），尽可能屏蔽掉具体的传输介质和物理设备
            差异，让上层数据链路层不必考虑传输介质带来的影响。
	
	   数据链路层：
			由于计算机网路中存在各种干扰，物理链路不可靠，这一层在物理层提供的比特流基础上，负责建立和管理节点
            间链路，通过各种控制协议（差错控制，流量控制方法等）解决同一网络节点之间的通信，将有差异的物理信道
            变为无差错的，能可靠传输数据帧的数据链路，即提供可靠的通过物理介质传输数据的方法，通常分MAC/LLC两
            层。（局域网内）
	
	   网络层：
			OSI模型中最复杂的一层，通信子网最高的一层，通过路由选择算法为报文或分组选择最适当的路径，数据链路
            的数据在网络层被转换成数据包，通过路径选择、分组组合、进/出路由等控制，将信息从一个网路设备传到另
            一个网络设备，解决不同子网间的通信。（各局域网之间）
	   
	   传输层：
			上三层的主要功能数数据处理，传输层主要是数据通信，是通信子网和资源子网的接口和桥梁，可靠传输（TCP）
            在必要时对数据 进行分割，传输到网络层，确保数据正确无误的传输到网络层，目标设备在指定时间内没有确认
            收到，数据将被重发，而不可靠传输（UDP）则只负责发送，不确保目标设备是否收到。
	   
	   会话层：
			用户应用程序和网络之间的接口，通过远程地址（为用户设计的域名），建立、组织、协调两个会话进程之间的
            通信，对数据交换进行管理
	   
	   表示层 ：
			对应用层的数据进行解释，格式化，压缩和解压，加密和解密等
	
	   应用层：
			模型的最高层，直接向用户提供服务，是用户与网络以及应用程序和网络间的直接接口，使的用户能够与网络进
            行交互式联系，该层的应用程序实现用户请求的服务，应用层为用户提供：文件服务、目录服务、文件传输服
            务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据
            库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实
            现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的
