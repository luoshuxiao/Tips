# redis是什么，有什么用？
**需要说明的是redis的安全策略默认是只能本地访问，有人误解redis.conf配置文件中bind后加上想要访问redis的服务器ip，该ip地址就可以访问redis，这个理解是错误的，bind是设置该redis服务用哪个ip来作为自身的ip，对自身进行访问的来源服务器无法限制，不过可以通过设置用户名密码或者所在服务器设置防火墙来限制访问来源**
### 1. redis是什么 -- 
#### a. redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存也可以持久化的日志型、key-value数据库，redis是单线程工作模型，提供多语言的API。

	redis的五种数据类型：
	   1）String: set/get操作，value可以是string或者数字，一般做一些复杂的计数功能的缓存
	   2）hash: value存放的是结构化对象，用这种数据结构存储用户信息，比如以cookieId作为key,
               设置30分钟为缓存过期时间，能很好的模拟出类似session的效果；
	   3)list：可以做简单的消息队列，也可以利用lrange命令，做基于redis的分页功能，性能极佳；
	   4)set ：可以做全局去重功能，利用交集、并集等操作可以计算共同喜好，全部喜好，自己独有的喜好等等功能；
	   5)sorted set ： 比set多了一个权重参数score,集合中的元素能按照score排序，可以做排行榜应用，
                       取top N操作，也可以用来做延时任务，可以做范围查找。
#### b. redis的内存淘汰机制和过期策略
	过期策略 -- 定期删除+惰性删除策略
	定时删除：用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗cpu资
	源。在大并发请求下，cpu要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。
	定期删除：redis默认是100ms检查是否有过期的key，有就删除。需要说明的是，并不是每隔100ms对
	每个key进行检查，而是随机抽取进行检查。
	惰性删除策略：在用户获取某个key的时候，redis会检查一下，这个key如果设置了过期时间，过期了
	就会在此时删除。
	所以，在定期删除+惰性删除结合下，仍然有没有检查到的key,那么就会采用内存淘汰机制。
	内存淘汰机制 -- redis.conf中有一行代码配置内存淘汰机制如下：
            # maxmemory-policy volatile-lru
	配置选项有以下情况：

	1） noeviciton :当内存不足以容纳新写入数据时，新写入操作会报错（报错不符合需求，不推荐）；
	2）allkeys-lru ： 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key；
	3）allkeys-random： 当内存不足以容纳新写入数据时，在键空间中，随机移除某个key；
	4）volatile-lru ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近
	最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用；
	5)volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key；
	6)vloatile-ttl： 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时
	间的key优先移除；
	ps:如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, 
       volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致


### 2. redis和其他持久化数据库混合使用时数据一致性问题 --
 
	首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供
	一个补偿措施即可，例如利用消息队列。这种方式也只能让最终的数据一致，但是如果对数据有强一致
	性要求，这类数据不能完全避免数据的一致性问题，这类数据就不能放缓存。
###3. 如何解决redis的并发竞争key问题 --